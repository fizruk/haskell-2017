Классы типов. Функторы
===

### Мотивирующий пример

Космос полон разных объектов.
Мы можем встретить там астероиды, космический мусор, НЛО.
Каждый из этих объектов представлен собственным типом в программе на Haskell. Нам необходимо перемещать каждый объект в соответствии с его скоростью, и для этого мы можем написать 3 различные функции.
Но можем ли мы написать универсальную функцию?

### Классы типов

Если мы хотим перемещать объекты разных типов, нам понадобится специальный или ad-hoc полиморфизм. Этот вид полиморфизма также известен как перегрузка функций.
Специальный полиморфизм позволяет использовать различные реализации функции в зависимости от типов значений, к которым эта функция применяется.
В Haskell специальный полиморфизм представлен механизмом классов типов.
Классы типов описывают своего рода интерфейсы для типов.
Важно отметить, что классы типов не имеют ничего общего с классами в объектно-ориентированном программировании!
Например, класс типов `Eq` предоставляет функции "равно" и "не равно" для сравнения значений заданного типа на равенство.
Классы типов объявляются при помощи ключевого слова `class`.
Далее следует имя класса типов и его параметр — переменная типа `a`.
После этого следует ключевое слово `where` и сигнатуры функций-методов класса.
При описании методов класса типов мы можем указать реализацию по умолчанию.
В случае `Eq` мы можем определить "равно" через "не равно" и наоборот.
Таким образом, мы можем получить реализацию функции "не равно" автоматически, реализовав только функцию "равно" для конкретного типа.
Выпишем реализацию экземпляра класса типов `Eq` для типа `Mark`.
Реализация начинается с ключевого слова `instance`, после которого следуют имена класса и типа, для которого определяется реализация.
Затем идёт ключевое слово `where` и реализация методов.
Реализуем функцию "равно".
Если слева и справа крестик — значения равны. Если слева и справа нолик — тоже равны. Иначе — значения различны и мы получаем `False`.
Функцию "не равно" мы получаем автоматически за счёт определения по умолчанию.
Мы можем также реализовать экземпляр класса `Eq` для списков.
Два списка равны, если все их элементы совпадают. А именно, два пустых списка равны друг другу.
Два непустых списка равны друг другу, если равны их головы и хвосты.
В любом другом случае списки не равны.
Заметим, что для определения операции "равно" для списков нам понадобилось сравнивать элементы списка.
Это значит, что реализация верна только тогда, когда тип элементов списка также принадлежит классу типов `Eq`.
Мы должны добавить соответствующее ограничение в нашу реализацию, чтобы отразить этот факт!

Классы типов, с которыми мы уже знакомы, реализованы аналогичным образом. Класс типов `Ord` предоставляет возможность сравнения на больше или меньше.
Заметим, что при описании этого класса мы указываем ограничение `Eq a`.
Это ограничение говорит о том, что любой тип `a`, который является экземпляром класса `Ord` должен также являться экземпляром класса `Eq`.
С точки зрения использования это значит, что ограничение `Ord a` содержит в себе ограничение `Eq a`, а значит последнее писать не обязательно.
Класс типов `Show` предоставляет среди прочего функцию `show` для преобразования значений в строку.
Эта функция используется в интерпретаторе GHCi для отображения значений.
Класс типов `Read`, можно сказать, противоположен классу `Show`.
Функция `read` позволяет перевести строку обратно в значение заданного типа. Поскольку не любую строку можно успешно перевести в значение, эта функция не вполне чистая и может выкинуть исключение и завершить выполнение программы.
Вместо неё рекомендуется использовать безопасные функции `readMaybe` и `readEither` из модуля `Text.Read`.
Класс типов `Enum` предоставляет интерфейс для перечислимых типов.
Синтаксис диапазонов работает с любыми типами этого класса! Например, мы можем получить все символы от 'a' до 'f'.
Класс типов `Bounded` предоставляет полиморфные константы `minBound` и `maxBound`, определяющие минимальное и максимальное значение заданного типа.
Класс типов `Num` предоставляет общие операции для работы над числами.
Если вы попытаесь узнать тип числа 123 в интепретаторе, он выдаст полиморфный тип с ограничением `Num t`.
Это потому что целые числа могут быть любыми числами! Класс типов `Num` определяет среди прочего операции сложения и умножения.
Чтобы входить в класс типов `Num` тип должен также входить в `Show` и `Eq`.
Класс типов `Integral` включает в себя целые числа, такие как `Int` и `Integer`, а `Floating` — числа с плавающей точкой, `Float` и `Double`.
Очень полезная функция при работе с числами — `fromIntegral`.
Эта функция преобразует целое число в любое число.

### Законы и автоматический вывод

Важная часть классов типов, которую, к сожалению, не контролирует компилятор — это законы, которые должны соблюдать все реализации методов.
Например, если мы используем сравнение при помощи операции "равно" мы полагаемся на привычные для нас свойства этой операции.
В частности, мы ожидаем, что `x == x` для любых `x`. Или, что из `x == y` и `y == z` следует `x == z`.
Заметим, что мы легко можем написать реализацию, которая не будет удовлетворять этим ограничениям.
Для класса типов `Eq`, разумеется, вряд ли кто-то будет писать реализацию, нарушающую законы, но, как мы увидим позже, для некоторых классов законы выглядят не так просто и следить за их выполнением может оказаться труднее.
Чтобы не напортачить с реализацией экземляров классов типов, лучше доверить эту работу компилятору.
И действительно, для многих классов типов компилятор может вывести реализацию экземпляров автоматически!
Для этого в конце определения типа необходимо добавить ключевое слово `deriving`, а затем список имён классов типов, для экземляров которых нужно вывести реализацию.
Таким способом мы можем получить реализацию для классов `Eq`, `Ord`, `Enum`, `Bounded`, `Show` и `Read`.
Автоматический вывод будет работать и для типов с параметрами, вроде `Maybe` и списков. Необходимые ограничения компилятор добавит в реализацию автоматически.

### Возвращение к мотивирующему примеру

Вернёмся в космос.
Чтобы реализовать универсальную функцию перемещения объектов, мы можем реализовать собственный класс типов! Действительно, для перемещения объекта нам необходимо получить его скорость, положение в пространстве и уметь изменять это положение.
Давайте объявим класс типов `Physical` с тремя методами — `getPosition`, `setPosition` и `getVelocity`.
Используя этот класс типов мы можем реализовать функцию `move`, принимающую время, объект и возвращающую новое состояние объекта.
Поскольку методы класса `Physical` делают простые вещи, мы легко можем выписать реализацию всех нужных экземпляров.
Как вы думаете, каким законам должны следовать реализации экземпляров класса `Physical`?
Ссылка на проект с моделированием космического мусора находится в описании под видео.
Успехов!
