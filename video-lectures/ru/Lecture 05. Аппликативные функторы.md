Аппликативные функторы
===

### Мотивирующий пример

Любая ролевая игра начинается с создания своего персонажа. Давайте реализуем меню выбора персонажа!
Меню будет состоять из панели с параметрами и изображением персонажа.
В панели можно выбрать имя, расу, класс, оттенок кожи персонажа,
а также настроить атрибуты — силу, ловкость, здоровье и энергию.
Наша панель состоит из слайдеров и элементов выбора.
При этом значения параметров имеют различные типы.
Можем ли мы, несмотря на это, построить панель модульно, просто объединяя несколько элементов?

### 

Поскольку параметры в панели разных типов, мы не можем использовать моноиды, нам нужно что-то другое.
Прежде, чем переходить к меню выбора персонажа, давайте рассмотрим модульность на более простых примерах.
Тип `Maybe a` может хранить ноль или одно значение типа `a`.
Мы можем получить такое значение, например, используя функцию `lookup`.
Допустим, мы получили два таких значения и теперь хотим сложить их.
Естественно, нас интересует сумма, только если оба слагаемых присутствуют.
Операция `+` не работает с типом `Maybe a`, но мы можем написать свою функцию.
Если оба значения присутствуют — возвращаем сумму, обёрнутую в `Just`.
Иначе — `Nothing`.
Аналогичным образом мы могли бы реализовать умножение, деление и прочие операции.
Но вместо этого давайте определим функцию высшего порядка `zipMaybeWith`.
Эта функция применяет функцию от двух аргументов к значением, если оба присутствуют.
Иначе — возращает `Nothing`.
Заметим, что тип `zipMaybeWith` похож на тип `fmap` для `Maybe`.
Функция `fmap` работает с функцией одного аргумента, а функция `zipMaybeWith` — с функцией двух аргументов.
Если мы передадим `fmap` функцию двух аргументов, мы получим значение типа `Maybe (b -> c)`.
Чтобы применить эту частично-применённую функцию ко второму аргументу, нам нужна функция, принимающая два значения `Maybe` на вход.
Первое — с частично применённой функцией, а второе — со вторым аргументом.
Функция `fmap` здесь бессильна, а вот `zipMaybeWith` мы можем использовать, передав ей операцию применения функции.
Для операции применения функции существует явный символ — доллар.
Хорошо, можем ли мы скомбинировать три значения `Maybe`?
Если мы частично применим функцию `zipMaybeWith f` к первым двум значениям, мы получим значение типа `Maybe (c -> d)`.
Эта ситуация напоминает ту, что была с `fmap`.
И тут мы можем использовать `zipMaybeWith` ещё раз, чтобы применить функцию к последнему аргументу.
Аналогичным образом, применяя `zipMaybeWith` нужное число раз, мы можем скомбинировать любое количество значений типа `Maybe`.
При этом каждый раз нам приходится использовать её для аргументов вида `Maybe (a -> b)` и `Maybe a`.
Давайте реализуем функцию, комбинирующую `Maybe`-функцию и `Maybe`-значение.
Функция `apMaybe` применяет функцию к аргументу, если оба присутствуют.
Иначе — возвращает `Nothing`.
Используя `fmap` и `apMaybe` мы можем скомбинировать произвольное число `Maybe`-значений.

###

Такие функции, как `lookup`, используют `Nothing` в качестве сигнала об ошибке.
Если у нас в программе много вычислений, которые могут завершиться неуспешно, мы можем объединить их при помощи `fmap` и `apMaybe`.
Но в таком случае мы потеряем информацию о том, что пошло не так, в случае `Nothing`.
Например, если мы вычисляем выражение с переменными, и для какой-то переменной неопределено значение,
`Nothing` не сможет указать на неизвестную переменную.
Чтобы получить больше информации, используем `Either String`.
Строка в конструкторе `Left` может сообщить нам, например, имя неизвестной переменной.
Мы можем объединить несколько значений `Either`, определив функцию `apEither`.
Как и в случае `Maybe`, мы можем применить функцию к аргументу, только если оба присутствуют.
Иначе — мы возвращаем первую ошибку.
Используя `fmap` и `apEither` мы можем скомбинировать несколько значений, которые могут завершиться неуспешно.

###

`apMaybe` и `apEither` позволяют применить функцию к аргументу, проводя необходимые сопоставления автоматически.
Другими словами, эти функции производят автоматическую обработку неуспешных вычислений.
Таким образом, обработка `Maybe` и `Either` становится побочным эффектом, не требуя от программиста производить сопоставления вручную.
Рассмотрим другой тип эффектов.
Поскольку в Haskell функции чистые, случайные значения могут быть получены только при помощи чистых генераторов псевдослучайных чисел.
Мы можем определить такой генератор самостоятельно, используя просто тип `Int`.
Чтобы получить случайное число типа `Int`, используя наш генератор, мы просто вернём его как есть.
Чтобы получить следующее значение генератора, воспользуемся линейным конгруэнтым методом, который представлен простой формулой.
Давайте теперь определим случайный бросок кубика.
Бросок кубика — это функция, принимающая на вход генератор, и возвращающая случайное число от 1 до 6.
Давайте бросим кубик трижды! Определим функцию `threeDice`.
Поскольку мы используем тот же генератор, эта функция вернёт 3 одинаковых значения.
Ведь функции у нас чистые!
Давайте модифицируем функцию броска кубика, чтобы она возвращала новое значение генератора, кроме значения кубика.
Теперь мы можем использовать результат предыдущего броска кубика, чтобы получить новое случайное значение.
Реализуем функцию `threeDice`, возвращающую список из трёх случайных бросков кубика.
Эта функция будет принимать на вход генератор и возвращать пару — список значений кубика, и новое значение генератора для дальнейших вычислений.
Для того, чтобы бросить очередной кубик, нам нужно получить генератор, полученный от предыдущего броска.
Заметим, что `dice` и `threeDice` имеют схожий тип — они обе принимают генератор на вход и возвращают новое значение генератора на выходе.
Мы можем таким же образом объединить функции генерации случайного числа и следующего генератора.
Переопределим `dice` при помощи новой функции `rand`.
Поскольку все функции, работающие с генератором, будут принимать его на вход и возвращать на выходе, определим тип-обёртку `Rand`.
Тип `Rand a` теперь представляет случайное значение типа `a`.
Чтобы получить такое значение, мы можем раскрыть обёртку и передать генератор на вход.
Мы можем переписать функцию `rand` в значение типа `Rand Int` — случайное число.
Заметим, что `Rand` — функтор.
Действительно, мы можем применить чистую функцию к случайному значению, чтобы получить новое случайное значение. Поскольку функция чистая, нам не нужно создавать новый генератор.
Новое значение будет обёрнутой функцией, которая принимает на вход генератор, вычисляет по нему случайное значение типа `a`, а затем применяет чистую функцию `f`.
Таким образом, `fmap` применяет чистую функцию к случайному значению!
Определим случайный бросок кубика, используя `fmap`.
Всё, что нам нужно, это получить остаток от деления случайного числа на 6 и прибавить единицу!
Отлично! Теперь, чтобы реализовать `threeDice`, нам необходимо скомбинировать три случайных значения.
Если передать `fmap` функцию от трёх аргументов, мы получим случайную частично применённую функцию.
Попробуем определить функцию `apRand`, применяющую случайную функцию к случайному аргументу.
Поскольку и функция, и аргумент случайны, нам нужно использовать разные генераторы.
Определим результат как обёрнутую в `Rand` функцию.
Эта функция принимает на вход генератор, вычисляет по нему случайную функцию и новый генератор.
Затем использует новый генератор, чтобы получить случайный аргумент для функции и применяет её.
Используя `fmap` и `apRand` мы можем определить функцию `threeDice`.
Заметим, что мы перенесли всю работу с генератором случайных чисел в функции `rand`, `fmap` и `apRand`.
Значения `dice` и `threeDice` не используют явно внутреннее представление `Rand`.
Для них случайная генерация — побочный эффект.
В качестве упражнения реализуйте функцию `moves`, определяющую случайный бросок для хода в нардах, используя функции `dice`, `fmap` и `apRand`.
В нардах бросают два кубика, но если выпал дубль (то есть два одинаковых значения), кубики удваиваются.
Например, если выпало две тройки, ход игрока будет состоять из четырёх перемещений по три позиции.

###

При обработке неуспешных вычислений и работе с генератором псевдослучайных чисел, мы столкнулись с необходимостью комбинировать значения с разными типами значений, но общим типом эффектом.
Тип эффектов в каждом случае задавался конструктором типов с одним параметром — `Maybe`, `Either e`, `Rand`.
И каждый раз комбинация значений была в некотором роде расширением функции `fmap`.
Тогда как `fmap` может только применять чистые функции к значениям с эффектами, `apMaybe`, `apEither` и `apRand` добавляли возможность работы с функциями нескольких аргументов. Функторы расширенные такой операцией комбинации называются аппликативными.
Аппликативные функторы представлены в Haskell классом типов `Applicative`.
`Applicative` является подклассом `Functor`, то есть любой аппликативный функтор должен быть функтором.
У этого класса два метода.
Операция `<*>` (произносится "эп") применяет обёрнутую функцию к обёрнутому значению.
Функция `pure` оборачивает значение, не применяя никаких эффектов.
Рассмотрим, например, реализацию экземпляра класса `Applicative` для `Maybe`. Тип методов для `Maybe` принимает такой вид.
Операция "эп" применяет функцию к аргументу, если оба присутствуют.
`pure` оборачивает значение в `Just`.
Для `Either e` реализация аналогична. Тип методов мы получаем, заменив `f` на `Either e`.
Операция "эп" применяет функцию к аргументу, только если оба присутствуют.
А `pure` оборачивает значение в `Right`.
В случае `Either` это единственная возможная реализация `pure`.
Для `Rand` реализация экземпляра класса типов `Applicative` также проста.
Операция "эп" применяет случайную функцию к случайному аргументу.
Реализация повторяет функцию `apRand`, которую мы реализовали ранее.
`pure x` — это случайное значение без эффектов. Иными словами, постоянная, которая не использует генератор случайных чисел.
В качестве упражнения реализуйте экземпляр `Applicative` для конструктора типов `Error`.
В отличе от `Either` `Error` накапливает ошибки со всех вычислений, возвращая список сообщений об ошибках.
Реализуйте функцию `eval`, вычисляющую значение выражения с переменными, и использующую `Error` для отслеживания ошибок.

###

Используя класс типов `Applicative`, мы можем легко менять представление эффектов.
Например, мы можем легко заменить `Maybe` на `Either String` в программе, которая не использует явное сопоставление с образцом.
Кроме того, мы можем реализовать полезные функции сразу для ряда эффектов.
Например, определим функцию `sequenceA`, принимающую на вход список значений с эффектами и объединяющую эффекты для всех значений.
Если список пуст — мы можем использовать функцию `pure`.
Если же список не пуст, мы можем взять первый элемент, рекурсивно объединить эффекта для хвоста списка, а затем объединить результаты при помощи операции конструкции списка. Поскольку оба аргумента у этой операции с эффектами, используем `fmap` и "эп" вместо обычной операции применения функции.
Мы можем использовать `sequenceA` для определения функции `threeDice`.
Поскольку при комбинации эффектов `fmap` и "эп" удобно использовать в инфиксной форме, для `fmap` есть удобный синоним — доллар в угловых скобках.
Теперь, чтобы применить функцию к нескольких аргументам с эффектами, мы можем просто заменить обычную операцию применения функции на `fmap` и "эп".

### Законы

Реализации экземпляров класса `Applicative` должны удовлетворять следующим законам:
Первый закон даёт нам связь между `fmap`, `pure` и "эп".
По сути, мы можем разбить применение функции к значению с эффектом на два шага — обернуть функцию, не применяя никаких эффектов.
А затем использовать "эп" для применения результата к аргументу.
Остальные законы следят за тем, чтобы `pure` действительно не применял никаких эффектов, а "эп" должным образом комбинировал эффекты.
Последний закон по сути представляет свойство ассоциативности эффектов.

###

Рассмотрим ещё несколько аппликативных функторов. Что если в качестве эффекта мы хотим, чтобы наши функции писали сообщения в лог?
Мы можем смоделировать лог, используя в качестве результата функции пару — значение и строка лога.
Например, мы можем определить значения `x` и `y`, представляющие два числа с логами "x" и "y".
Чтобы сложить два таких числа, мы можем определить тип `Log a` для значения с логом, и определить экземпляр класса `Applicative`.
При комбинации двух значений их логи просто конкатенируются. Отсутствие эффектов в этом случае — пустой лог.
Теперь мы можем сложить `x` и `y`, используя `fmap` и "эп".
Мы можем также присвоить лог каждой операции. Мы можем даже определить экземпляр класса `Num` для `Log a`, используя аппликативный функтор.
Теперь записывать выражения можно в привычном для нас виде.
На выходе мы получим результат и обратную польскую нотацию для выражения!
В общем случае лог не обязан быть строкой. Достаточно, чтобы логи можно было склеить и существовал пустой лог.
Другими словами — любой моноид подойдёт.
Мы можем определить экземпляр `Applicative` для любого кортежа, содержащего моноид.
Действительно, создание кортежа — это применение конструктора типов к двум типам параметрам.
Мы можем зафиксировать первый параметр, и определить экземпляры классов `Functor` и `Applicative`.
Второе значение кортежа — это чистое значение, с которым мы обычно работаем, а первое — обобщённый лог.
`fmap` будет просто применять функцию ко второму значению в кортеже.
`pure` будет создавать пару с пустым логом — `mempty`.
"эп" будет конкатенировать логи при помощи `mappend`.

###

Иногда значения в программе зависят от внешних параметров.
Например, от размера экрана, каких-то параметров моделирования или конфигурационного файла.
Мы можем определить значение `x`, представляющее переменную с именем "x". Пускай значение этой переменной зависит от таблицы значений переменных.
По сути `x` — это функция поиска значения в таблице.
Аналогичным образом мы можем определить другие переменные.
Чтобы сложить две такие переменные мы должны взять таблицу значений, найти в ней каждую переменную и сложить полученные значения.
Работа с таблицей значений — это эффект, для которого мы можем определить аппликативный функтор.
Работа с таблицей — это по сути любая функция, принимающая на вход таблицу.
Стрелочка, определяющая функцию, — это тоже конструктор типов с двумя параметрами!
Зафиксируем первый тип-параметр и попробуем определить экземпляры `Functor` и `Applicative`.
`fmap` применяет функцию `f` к результату функции `g`.
Другими словами, `fmap` — это композиция функций!
"эп" комбинирует две функции с общим параметром. Результат — это функция, которая принимает параметр на вход,
вычисляет каждое из двух значений и применяет функцию к аргументу.
`pure` будет игнорировать параметр.

### Возвращение к мотивирующему примеру

Вернёмся к созданию своего персонажа.
Мы можем построить панель с настройками персонажа модульно, определив конструктор типов `Panel`.
Тип `Panel a` представляет панель с настройками объекта типа `a`.
В нашем случае наша панель будет иметь типа `Panel Character`.
Каждая панель состоит из набора элементов-полей и функции-представления, вычисляющей значение типа `a` по значениям полей.
На случай, если какое-то поле содержит недопустимое значение, мы оборачиваем значение типа `a` в `Either Fields`.
Значение типа `Field` в конструкторе `Left` мы можем использовать, чтобы сбросить поля с некорректными значениями.
Каждое поле — это либо слайдер, либо элемент выбора.
Мы можем составлять панели из панелей поменьше, помещая одну под другой.
Определим экземпляр класса `Applicative` для `Panel`.
Функция `pure` создаёт пустую панель, для которой функция-представление возвращает заданную константу, обёрнутую в `Just`.
Операция "эп" объединяет списки полей и комбинирует функции-представления.

Для каждого типа поля определим функцию, строящую панель из одного поля этого типа.
Для слайдера определим функцию `slider`, а для элемента выбора — функцию `selector`.
Мы можем построить произвольные панели, используя эти базовые поля и интерфейс аппликативного функтора.
В частности, рассмотрим упрощённую модель персонажа.
Персонаж представлен типом `Character` с одним конструктором значений `Character` и тремя полями — расой, здоровьем и энергией.
Для каждого свойства персонажа мы можем определить поле ввода, используя функции `slider` и `selector`.
Чтобы объединить значения этих полей мы можем использовать конструктор значений `Character`.
Чтобы при этом поля объединились в единую панель, используем интерфейс аппликативного функтора.
Чтобы завершить проект нам нужно добавить поля ввода для оставшихся свойств персонажа.
Для этого используйте интерфейс аппликативного функтора и функции `slider` и `selector`.

Проект с меню выбора персонажа находится в описании под видео.
Успехов!
