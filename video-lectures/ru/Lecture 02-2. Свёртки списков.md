Свёртки списков
===

### Мотивирующий пример

Крестики-нолики — одна из простейших игр.
И тем не менее она остаётся довольно популярной и имеет множество вариаций, включая Рэндзю — спортивный вариант крестиков-ноликов.
Рассмотрим вариацию игры на произвольном прямоугольном поле NxM,
где для победы требуется выстроить ряд из K фишек подряд
по горизонтали, вертикали или диагонали.
Каждая ячейка поля либо пуста, либо занята фишкой одного из двух игроков.
В нашей реализации игроки представлены перечислением `Mark`, имеющим два значения — крестик и нолик.
Ячейка представлена синонимом `Maybe Mark`, а игровое поле
списком списков ячеек, где каждый из вложенных списков представляет одну строку поля.
Нам нужно реализовать функцию, определяющую победителя по состоянию игрового поля, если такой есть.
Для реализации нам потребуется анализировать линии — строки, столбцы и диагонали поля.
А для каждой линии находить сегмент из следующих подряд фишек.
Похоже нам предстоит изрядно повозиться со списками!

### Функции для работы со списками

Списки — это одна из наиболее распространённых структур в функциональном программировании.
Хотя списки — редко хороший выбор структуры для хранения, они вполне подходят для прототипирования.
Ленивые списки часто используются в качестве управляющих структур, перенаправляя вывод одной функции на вход другой.
Поэтому неудивительно, что для списков существует множество полезных функций.
Мы уже знакомы с функцией `map`, которая применяет заданную функцию к каждому элементу списка.
Конкатенация двух списков происходит при помощи операции `++`.
Конкатенация списка списков — при помощи функции `concat`.
Развернуть список можно при помощи функции `reverse`.
Иногда нам нужны не все элементы списка, и в таком случае полезна функция `filter`.
Функция `filter` принимает на вход предикат для значений типа `a`, список элементов типа `a` и
возвращает список, состоящий только из тех элементов, которые удовлетворяют предикату.
Например, мы можем оставить только положительные значения в списке, используя функцию `filter`.

В то время как функция `filter` оставляет все элементы, удовлетворяющие предикату,
иногда нас интересует только один результат. В таком случае используется функция `find`, которая принимает на вход предикат, список значений типа `a` и возвращает значение типа `Maybe a`.
Напомню, что тип `Maybe a` имеет два конструктора значений.
Конструктор `Nothing` — это аналог пустого списка для `Maybe a`, он не содержит ничего.
Конструктор `Just` может хранить ровно одно значение типа `a`.
Таким образом `Maybe a` — это ноль или одно значение типа `a`.
Функция `find` таким образом возвращает `Nothing`, если ни один элемент заданного списка не удовлетворяет предикату,
или `Just x`, если `x` — это первый элемент входного списка, который удовлетворяет предикату.
Функция `lookup` ищет значение в ассоциативном списке по заданному ключу.
Она принимает на вход ключ, список пар `<ключ, значение>` и возвращает значение, если пара с заданным ключом присутствует в списке.
Для сравнения ключей функция `lookup` использует ограничение `Eq a`.

Мы также знакомы с функцией `take`, которая оставляет лишь префикс заданной длины от входного списка.
Её противоположный аналог — функция `drop`, которая наоборот оставляет всё, кроме префикса заданной длины.
Функция `takeWhile` оставляет префикс списка, в котором каждый элемент удовлетворяет заданному предикату.
Функция `dropWhile` напротив убирает префикс списка, в котором каждый элемент удовлетворяет предикату.
Целый класс функций сводит списки к одному значению.
Функции `sum` и `product` вычисляют сумму и произведение.
Функции `and` и `or` вычисляют логическое И и логическое ИЛИ соответственно для списка значений типа `Bool`.
Функция `length` вычисляет длину списка, не затрагивая его элементов.
Функция `elem` проверяет наличие элемента в списке.

### Свёртки

Как мы видим, существует множество функций для работы со списками.
Но есть одна функция, что правит всеми — правая свёртка списка.
Чтобы разобраться, сначала определимся, что такое свёртка списка.
Свёрткой списка называется функция, проходящая по всем элементам списка, накапливающая результат и возвращающая его в конце прохода.
Существует два вида свёртки — левая и правая.
Левая свёртка проходит по списку слева направо, а правая — справа налево.
Если быть точнее, левая свёртка — это функция высшего порядка, принимающая на вход три аргумента:
функцию шага свёртки, начальное значение аккумулятора и список, по которому необходимо пройти слева направо.
При левой свёртке функция шага сначала применяется к начальному значению и первому элементу списка.
Затем функция шага применяется к результату предыдущего шага и следующему элементу списка.
Как мы видим, функция шага ассоциируется слева.
Правая свёртка также принимает три аргумента на вход, но проходит список справа налево.
Сначала функция шага применяется к последнему элементу списка и начальному значению аккумулятора.
Затем функция шага применяется к предыдущему элементу и результату предыдущего шага.
Таким образом, при правой свёртке функция шага ассоциируется справа.

Поначалу может показаться, что правая свёртка неэффективна.
Действительно, кажется, что для выполнения первого шага необходимо пройти весь список до конца.
Однако, мы должны помнить, что в Haskell ленивый порядок вычислений,
а значит в первую очередь будет выполнен тот шаг, который не находится в скобках.
Для левой свёртки — это шаг с последним элементом, а для правой — шаг с первым элементом списка.
Выходит, если функция шага свёртки не требует вычисления второго аргумента, правая свёртка завершится мгновенно.
При этом если функция шага свёртки не требует вычисления первого аргумента, левая свёртка всё равно будет вынуждена пройти входной список до конца.
Различия правой и левой свёрток даёт им две различные области применения.
Если функция шага свёртки ленива — например, логическое И — подойдёт правая свёртка, поскольку она может завершиться, не доходя до конца списка.
Если же функция шага свёртки неленива — например, сложение или максимум — лучше подойдёт левая свёртка.

Правая свёртка — это естественная свёртка списка в том смысле, что её аргументы соответствуют правым частям уравнений при обычном определении функций над списками.
Поскольку в уравнении для непустого списка функция шага свёртки `g` находится на верхнем уровне, именно она определяет, будет ли вычисляться хвост списка.
Это позволяет правой свёртке завершиться, не доходя до конца входного списка.
Например, функция `and` может быть реализована при помощи правой свёртки.
В действительности, поскольку правая свёртка соответствует обычной рекурсивной функции над списками, с помощью неё можно реализовать любую из ранее упомянутых функций.
Попробуйте реализовать функцию `filter`, используя правую свёртку.

Левая свёртка вынуждена проходить список до конца, поэтому не получает никакого выигрыша от ленивого порядка вычислений.
Однако, она может быть эффективна при энергичном порядке вычислений.
Функция `foldl'` — это энергичный вариант левой свёртки.
С функцией `foldl'`, проходя список слева направо, на каждом шаге мы будем вычислять новое значение аккумулятора, прежде, чем перейти к следующему элементу списка. Это позволяет избежать раскрытия свёртки в большое выражение.
Функции `sum`, `product` и `length` работают эффективнее, если реализуются с использованием энергичной левой свёртки.

### zipWith

Окей, что если у нас на входе два списка?
Функция `zip` позволяет "сжать" два списка в один, объединяя элементы попарно.
При помощи функций `zip` и `map` мы можем вычислить скалярное произведение векторов, заданных списками.
Итоговый список, выдаваемый функцией `zip`, имеет длину, равную длине самого короткого из входных списков.
При этом хвост длинного списка не используется и не будет вычислен.
Комбинация функций `zip` и `map` встречается настолько часто, что существует функция `zipWith` являющаяся их композицией.
Мы можем упростить реализацию скалярного произведения, используя функцию `zipWith`.

### Возвращение к мотивирующему примеру

Вернёмся к определению победителя в игре «Крестики-нолики».
Для определения победителя нам необходимо построить список всех линий игрового поля,
затем определить победителя для каждой линии и, наконец, выбрать первый результат из итогового списка.
Линии игрового поля — это строки, столбцы и диагонали.
Представление игрового поля — это список строк, поэтому для получения строк нам не нужно ничего делать.
Для получения столбцов нам необходимо транспонировать список списков. Для этого мы используем функцию `transpose` из модуля `Data.List`.
Для получения левых диагоналей, начинающихся на верхней границе поля, мы сначала отбрасываем ячейки под диагональю при помощи функции `zipWith drop [0..]`, а затем транспонируем результат.
Левые диагонали, идущие до нижней границы поля — можно вычислить тем же способом для транспонированного игрового поля.
При этом первая диагональ в обоих случаях будет главной диагональю, поэтому мы исключим её из второго списка.
Правые диагонали мы можем получить, просто вычисляя левые диагонали для отражённого игрового поля.
Отразить поле мы можем при помощи функции `reverse`.
Чтобы определить победителя на линии, разобьём её на сегменты, состоящие из одинаковых фишек, а затем найдём сегмент с нужным числом фишек подряд.
Чтобы разбить линию на сегменты реализуем функцию `segments`. Если линия пуста — сегментов нет.
Иначе мы начинаем сегмент. Он будет состоять из элементов равных голове списка. Таких элементов будет ровно на один больше, чем в префиксе хвоста списка.
Чтобы вычислить оставшиеся сегменты мы удаляем префикс и рекурсивно вызываем функцию `segments`.
Заметим, что поскольку `takeWhile` и `dropWhile` ленивы, функция `segments` также ленива.
Теперь, чтобы определить победителя среди сегментов, пройдёмся по списку сегментов, используя правую свёртку.
Шагом свёртки будет функция `compareSegments`, которая проверяет очередной сегмент и, если он состоит из фишек игроков и имеет нужную длину, то мы знаем победителя. Иначе — просматриваем список дальше.
Поскольку функция `compareSegments` ленива по второму аргументу, поиск победителя линии будет вычисляться ленивым образом.
Остаётся выбрать победителя из списка победителей линий.
Этот список состоит из значений типа `Maybe Mark` и нам нужно выбрать первое значение `Just`, если такое имеется, либо вернуть `Nothing`.
Реализуем эту функцию также при помощи правой свёртки.
Шагом свёртки будет функция `first`, принимающая два значения типа `Maybe Mark`, и возвращающая первое значение с конструктором `Just`, если такое есть.
Функция `first` ленива, как и все предыдущие функции, а значит, вся функция `winner` ленива и будет выполнять минимум работы.
В частности, если линия победителя находится в строке, столбцы и диагонали не будут вычисляться и проверятся.

В качестве упражнения реализуйте эвристическую функцию `estimate`, оценивающую ситуацию на поле.
Эта функция считает длину всех сегментов для каждого игрока и возвращает пару `<суммарная длина для крестиков, суммарная длина для ноликов>`.
Заметим, что суммарная длина может быть больше кол-ва фишек на поле, ведь некоторые фишки могут участвовать в двух, трёх, или даже четырёх сегментах.

Ссылка на проект «Крестики-нолики» находится в описании под видео.
Успехов!
