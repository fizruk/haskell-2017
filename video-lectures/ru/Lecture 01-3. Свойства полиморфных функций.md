Свойства полиморфных функций
===

### Мотивирующий пример

Представьте, что вы работаете с конечным автоматом и хотите определить язык, который он допускает.
Автомат задан начальным состоянием типа State, функцией isFinal, которая проверяет, является ли состояние конечным, и функцией transition,
которая определяет множество переходов из заданного состояния.
Каждый переход представлен парой (символ, новое состояние).
Ваша задача определить язык по заданному начальному состоянию.
Реализация такой функции может быть нетривиальна. Но если сделать шаг назад и абстрагироваться от ненужных деталей, окажется, что реализацию можно получить почти механически.

### Единственная реализация

На практике параметрический полиморфизм настолько ограничивает возможные реализации функции,
что иногда остается всего одна возможная реализация.
Например, представьте функцию из Int в Int.
Сколько возможных реализаций существует для такой функции?
Огромное количество! Поскольку мы знаем множество функций для работы с целыми числами,
мы можем просто вернуть 42, возвести аргумент в квадрат
или посчитать кол-во простых чисел, которые меньше аргумента.
Теперь представьте функцию из a в a.
Сколько возможных реализаций существует для этой функции?
Мы ничего не знаем про тип a, а значит, ничего не можем с ним сделать...
Кроме одного — вернуть его как есть!
Таким образом параметрический полиморфизм оставляет нам единственную реализацию:
тождественную функцию id.
Теперь рассмотрим функцию, принимающую кортеж типов a и b, и возвращающую значение типа a.
Поскольку нам нужно вернуть значение типа a, о котором мы снова ничего не знаем,
единственный выход — выбрать первый элемент кортежа.
Заметим, что в месте применения a и b могут быть одинаковыми,
например, кортеж из двух чисел часто служит в качестве вектора.
Однако, при реализации функции мы не можем проверять равенство типов
и должны написать реализацию в общем виде.
Хорошо, рассмотрим теперь функцию высшего порядка,
принимающую функцию из a в b, значение типа a и возвращающую значение типа b.
Поскольку мы ничего не знаем про b, единственный способ получить значение этого типа —
это применить функцию из a в b. И у нас имеется ровно один кандидат в аргумент для этой функции.
Параметрический полиморфизм снова оставляет нам единственную возможную реализацию —
мы можем только применить функцию к аргументу!
Заметим, что применить функцию мы можем ровно один раз,
поскольку результат будет типа b и мы не сможем применить функцию повторно.

### iterate

Отлично, перейдём к функциям, где реализация чуть менее очевидна.
Возьмём функцию, принимающую функцию из a в a, значение типа a,
и возвращающую значение типа a.
Тип этой функции очень похож на тип операции применения функции,
но в этом случае a равно b.
А это значит, что мы можем повторно применять функцию к результату.
Мы можем вызывать функцию f один раз, два раза, три раза...
Мы можем даже применить функцию f ноль раз, игнорируя первый аргумент.
Или мы можем уйти в бесконечную рекурсию, игнорируя второй аргумент.
Однако, на этом наши возможности исчерпываются.
Окей, что если мы будем возвращать не одно значение типа a, а целый список таких значений?
Мы видели, что одно значение мы можем получить применяя функцию f к аргументу ноль или более раз.
Значит, наш список будет состоять из таких значений... И самый простой способ получить этот список — это вернуть *все* такие значения!
Действительно, головой списка может быть просто наш второй аргумент икс, а хвостом — рекурсивный вызов нашей функции с (f x) в качестве второго аргумента.
Поскольку у нашей функции нет границы рекурсии, полученный список оказывается бесконечным. Это возможно благодаря ленивому порядку вычислений в Haskell и, в частности, ленивости операции конструкции списка.
Мы обсудим ленивость подробнее в следующий раз.
Кстати, функция, которую мы только что реализовали, называется iterate и доступна по умолчанию.
Обратите внимание, что порядок значений в этом списке не обязан быть таким, как мы реализовали. Но все реализации, которые меняют порядок — менее естественны в том смысле, что необходимо написать дополнительный код.
Заметим также, что функция может теоретически возвращать конечный список, но размер конечного списка не может зависеть от входных параметров из-за параметрического полиморфизма,
а значит должен быть "вшит" в реализацию, что опять же делает её менее естественной.

### 

Хорошо, рассмотрим теперь функцию, которая принимает список на вход.
Стандартная функция length принимает список значений типа a и возвращает число — длину списка.
Поскольку мы ничего не знаем про тип a, результат функции не может зависеть от значений, хранящихся в списке.
Значит, результат может зависеть только от формы списка. А форма списка определяется только его длиной!
Выходит функция length — это по сути функция длины входного списка.
Естественно, самая простая такая функция просто вернёт длину.
Теперь, когда мы рассмотрели функции со списками на входе и выходе отдельно, рассмотрим функцию map.
Напомню, что функция map принимает на вход функцию из a в b, список элементов типа a и возвращает список элементов типа b.
Чтобы получить элементы типа b мы вынуждены применять функцию f к элементам типа a, которые мы можем взять только из входного списка.
Реализация функции map, с которой мы уже знакомы, является самой естественной реализацией функции с таким типом. 
Любая другая реализация может только удалить, дублировать и перемешать элементы в списке.
Причём, как и в случае с length, эти дополнительные операции могут зависеть только от длины входного списка.

### 

Вернёмся к задаче с конечным автоматом.
Вместо того, чтобы полагаться на знания о типах автомата, нам достаточно знать, что есть два различных типа — тип состояний и тип символов.
Обозначим тип состояний переменной s, а тип символов переменной a.
Чтобы определить, является ли состояние конечным, нам понадобится функция из s в Bool. Функция переходов теперь будет функцией из s в список пар (a, s).
Если мы определим полиморфную функцию, принимающую на вход функцию окончания, функцию переходов и начальное состояние,
мы сможем выполнить исходную задачу как частный случай.
На первый взгляд может показаться, что мы усложняем себе задачу.
Но на самом деле мы просто убрали лишние знания и тем самым уменьшили количество возможных реализаций.
А, значит, мы уменьшили и вероятность некорректной реализации.
Начнём выписывать реализацию этой функции.

У нас есть значение типа s, и две функции, принимающие такое значение.
Для начала используем предикат, чтобы проверить, является ли s конечным состоянием.
Если да — наш язык состоит лишь из одного пустого слова.
Иначе мы вычисляем все возможные переходы и получаем список пар (a, s).
Поскольку функции окончания и переходов не изменятся, мы можем считать, что для рекурсивного вызова у нас есть функция из s в список списков a.
Можем ли мы получить результат используя только список пар (a, s) и функцию из s в список списков a?
Во-первых, мы можем применить эту функцию к каждому s в списке пар (a, s), чтобы получить список пар (a, список списков a).
В каждой паре первый элемент — это символ, который стоит в начале каждого слова,
поэтому нам стоит присоединить этот символ к каждому слову в списке, который является вторым элементом пары.
Теперь мы получили список списков слов и нам остаётся просто объединить списки слов, используя функцию concat.
Проверим нашу реализацию на тестовом автомате.
Работает идеально!
Реализация была не самой очевидной, но ограничения параметрического полиморфизма на каждом шаге практически не оставляли нам выбора.
Попробуйте самостоятельно реализовать функцию, принимающую на вход автомат, слово (список символов)
и возвращающую список последовательностей состояний, соответствующих этому слову.
Если автомат не допускает слово, список будет пустым.
Если автомат недетерминированный, список может содержвать более одной последовательности.
Если же автомат детерминированный, то список будет содержать ровно одну последовательность.
Небольшая подсказка: вам понадобится ограничение Eq a, для поверки символов на равенство.
Ссылка на проект с моделированием конечных автоматов находится в описании под видео.
Успехов!

