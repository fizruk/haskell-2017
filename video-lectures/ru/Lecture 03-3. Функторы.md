Классы типов. Функторы
===

### Мотивирующий пример

Допустим, мы реализуем простой калькулятор арифметических выражений с переменными.
Наш калькулятор поддерживает операции сложения и умножения, целые числа и переменные.
Нам необходимо реализовать функцию, вычисляющую значение выражения,
а также функцию, переводящую выражение в строку.
Первая функция принимает на вход ассоциативный список значений переменных, значение по умолчанию для переменных, чьё значение неизвестно,
исходное выражение и возвращает число — результат вычисления выражения.
Вторая функция принимает на вход функцию отображения имён переменных, выражение и возвращает строковое представление.
Какой тип нам стоит использовать для представления выражения?
И как лучше реализовать функции вычисления и отображения?

### MapReduce

Работая со списками мы видели множество различных функций.
Во многих задачах нам приходилось использовать функцию `map`, которая работает с каждым элементом списка, не затрагивая его структуру.
Другие полезные функции, такие как `filter`, `takeWhile` и `reverse` изменяли структуру списка, но не меняли его элементов.
Наконец, мы использовали свёртки списков, чтобы получить нужный нам результат, схлопнув весь список в единое значение.
Подход, при котором обработка данных делится на предобработку (при помощи `map`) и свёртку, находит широкое применение в распределённых вычислительных системах.
Одним из наиболее известных применений этого подхода является, пожалуй, фреймворк MapReduce компании Google, предназначенный для обработки огромных (в несколько петабайт) наборов данных.
Эта же идея используется в проекте Hadoop, который используется компаниями Yahoo! и Facebook.
Функциональная природа языка Haskell позволяет нам использовать этот подход также и на меньших масштабах — в обычных программах.
Однако списки далеко не всегда оказываются подходящей структурой для организации наших данных.
Например, иногда удобно организовывать данные в деревьях, сетках, векторах, стеках, очередях, хэш-таблицах и других структурах.
Можем ли мы использовать подобный подход с предобработкой данных и последующей свёрткой, используя другие структуры?

### Типы и виды

Взглянем на тип функции `map`.
Чтобы лучше понять, как мы можем обощить эту функцию, заменим квадратные скобки на конструктор типов `List`.
Мы хотим иметь возможность заменять список на любую другую структуру.
Например, дерево или стек.
Заметим, что `List`, `Tree` и `Stack` не являются типами! Это *конструкторы* типов.
То есть мы хотим перегрузить функцию `map` для *конструкторов* типов.
Но любой конструктор типов не подойдёт.
Например, конструктор `AssocList` принимает два параметра — тип ключей и тип значений.
Если бы мы хотели реализовать функцию `map` для значений ассоциативного списка, нам пришлось бы заменить `List` на `AssocList k`.
Оказывается, у типов и конструкторов типов есть свои типы. Такие типы типов называются *виды*.
У всех типов, которые могут иметь значения, вид "звездочка".
Конструкторы типов, принимающие один тип-параметр (например, `Maybe`, список и `Tree`) имеют вид `* -> *`.
В самом деле, вывод видов для типов следует такому же процессу, как и вывод типов для значений.
Проверить вид типа в интерпретаторе можно при помощи команды `:k`.
Тип `Either` имеет вид `* -> * -> *`.
Как и функции на уровне значений, конструкторы типов каррированы и могут быть частично применены.
Например, тип `Either String` имеет вид `* -> *`.
Теперь взглянем ещё раз на тип функции `map`.
Мы видим, что `a`, `b`, `List a` и `List b` — типы, поскольку должны иметь значения.
Поскольку `List a` и `a` типы, выходит `List` — это конструктор типов, который принимает тип и возвращает тип.

### Класс типов `Functor`

Классы типов в Haskell работают не только с обычными типами, но и с конструкторами типов.
Это значит, что мы можем перегрузить функцию `map` для использования с различными конструкторами типов.
В стандратной библиотеке определён класс типов `Functor` с единственным методом `fmap`.
Заметим, что тип функции `fmap` — это тип функции `map`, в котором заменили список на переменную `f`.
Да, переменные конструкторов типов также разрешены в Haskell!
Функция `fmap` применяет функцию из `a` в `b` к каждому элементу типа `a` в структуре `f a` и возвращает значение типа `f b`.
Выпишем реализацию экземпляра класса типов `Functor` для списков.
Действительно, `fmap` для списков — это уже знакомый нам `map`.
`Maybe a` содержит ноль или один элемент типа `a`, можем ли мы определить `Functor` для `Maybe`?
Вид `Maybe` подходит, давайте попробуем!
Тип `fmap` для `Maybe` мы можем получить, заменив `f` на `Maybe`.
Если на входе `Nothing` — нам не к чему применять функцию и мы вынуждены вернуть `Nothing`
Если на входе `Just x`, мы применяем функцию к единственному элементу.
Теперь мы можем применять функции из `a` в `b` к значениям типа `Maybe a`, используя `fmap`.
Заметьте, что это выглядит лаконичнее, чем сопоставление с образцом!
Хорошо, давайте реализуем экземпляр класса типов `Functor` для деревьев.
Тип `fmap` для `Tree` мы можем получить, заменив `f` на `Tree`.
Если дерево пустое — мы оставляем его пустым. Иначе — применяем функцию к элементу в узле дерева и рекурсивно вызываем `fmap f` для поддеревьев.
Отлично, можем ли мы теперь реализовать экземпляр класса типов `Functor` для `Either`?
Хм.`Either` требует двух параметров, а нам нужен конструктор с одним!
Мы можем частично применить `Either`, передав ему лишь один параметр и выписать реализацию для нового конструктора типов.
Тип `fmap` для `Either e` мы получаем, заменив `f` на `Either e`.
Для конструктора `Right` мы получаем значение типа `a`, к которому мы можем применить функцию `f`.
Для конструктора `Left` мы получаем значение типа `e`. Функцию `f` тут применять не к чему, поэтому мы возвращаем просто `Left x`.

### Законы функторов

Класс типов `Functor`, как и большинство классов типов, не обходится без законов.
Какого поведения мы ожидаем от функции `fmap`?
Мы ожидаем, что эта функция применит заданную функцию к каждому элементу в структуре, и при этом не изменит исходную структуру.
Оказывается, мы можем формализовать это свойство при помощи двух простых законов.
Во-первых, если мы применим тождественную функцию к каждому элементу, ничего не должно измениться.
Иными словами `fmap id == id`.
Во-вторых, если мы применим к каждому элементу функцию `f`, а затем функцию `g`, то результат должен быть такой же, как если бы мы применили к каждому элементу композицию функций `f` и `g`.
Первый закон выглядит довольно просто и его легко проверить.
Второй закон выглядит сложнее, к тому же мы должны перебрать все возможные `f` и `g`.
Однако, параметрический полиморфизм помогает нам с проверкой этих законов.
Оказывается, если первый закон выполняется, параметрический полиморфизм требует, чтобы второй закон также выполнялся!
Это означает, что при реализации экземпляра класса типов `Functor` нам достаточно проверить лишь первый закон!
В качестве упражнения реализуйте экземпляр класса типов `Functor` для дерева квадрантов.
Убедитесь, что первый закон выполняется для вашей реализации.

### Вывод реализации

Вы заметили, как реализация `Functor` получалась практически механически?
Поскольку новые типы в Haskell строятся при помощи альтернатив и кортежей, должно быть просто найти все вхождения элементов типа `a` в структуру типа `f a`. Хотя в реальности всё немного сложнее, компилятор дейсвительно может это сделать!
Однако, вывод этого класса типов не входит в стандарт языка. Поэтому нам требуется включить расширение.
Для этого поместите строчку `LANGUAGE DeriveFunctor` в самом верху вашего исходного файла.
Готово! Теперь вы можете добавить `Functor` к списку выводимых классов типов и, вуаля, ваш тип поддерживает обобщённый `map`.

### Возвращение к мотивирующему примеру

Вернёмся к задаче с арифметическими выражениями.
Для реализации обеих функций — вычисления и отображения — нам необходимо применить функцию к каждой переменной в выражении.
И правда, в случае вычисления выражения нам необходимо получить значение каждой переменной, исходя из ассоциативного списка значений и значения по умолчанию. В случае отображения, нам необходимо определить представление для каждой переменной.
Давайте объявим тип выражений таким образом, чтобы мы могли легко применять функции к каждой переменной.
А именно, объявим тип `Expr a` для выражений с переменными типа `a`. У этого типа будет четыре конструктора значений.
Конструктор для целых чисел. Конструктор переменных типа `a`. Конструктор для операции сложения. И конструктор для операции умножения.
Теперь мы можем реализовать вычисление выражения в два этапа — подставить значение для каждой переменной и вычислить итоговое выражение без переменных.
В нашем случае выражение без переменных будет иметь тип `Expr Int`. Мы можем легко определить функцию, вычисляющую такое выражение!
Значение числа — это само число. Вместо переменных у нас стоят также числа.
Для конструктора операции сложения мы вычисляем сумму, а для умножения — произведение подвыражений.
Чтобы получить значение одной переменной, мы используем поиск по ассоциативному списку — функцию `lookup`.
Если переменная находится в списке — мы выбираем её значение, иначе — используем значение по умолчанию.
Вычислить значение выражения с переменными мы можем теперь, подставив значение для каждой переменной при помощи функции `fmap`, после чего вычислив полученное выражение без переменных.
Для перевода выражения в строку используем тот же подход. Сначала реализуем функцию отображения для типа `Expr String`, считая, что каждая переменная уже находится в нужном представлении.
Затем реализуем общую функцию, применяя функцию отображения к каждой переменной выражения, после чего используя упрощённую функцию отображения для полученного выражения типа `Expr String`.
Давайте немного расширим возможности нашего калькулятора и разрешим переменным иметь в качестве значений другие выражения.
Реализуйте функцию `expandVars`, принимающую на вход ассоциативный список значений переменных, значение по умолчанию, исходное выражение и возвращающую новое выражение, в котором вместо значений переменных подставлены соответствующие подвыражения.

Ссылка на проект с вычислением простых арифметических выражений находится в описании под видео.
Успехов!
