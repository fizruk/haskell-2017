Ленивый порядок вычислений
===

### Мотивирующий пример

Написание игр — это увлекательное и в то же время очень познавательное занятие!
Давайте рассмотрим реализацию игры Flappy Lambda.
В этой игре мы управляем персонажем, символом лямбда, который летит по бесконечной вселенной
и должен протиснуться в узкие ворота, расположенные на пути.
Наше управление состоит из одного действия — подпрыгнуть.
Кол-во очков, набранное в игре — это кол-во ворот, которые мы успешно пролетели.

В этой игре нам необходимо реализовать генерацию вселенной. А именно, генерацию ворот на пути персонажа.
Ворота находятся на одинаковом расстоянии друг от друга, но могут находится на случайной высоте.

Мы можем выбрать представление ворот во вселенной и должны реализовать
функцию инициализации ворот и функцию обновления ворот.
Последняя принимает на вход время, прошедшее с последнего кадра и предыдущее состояние ворот.

В какой момент и в какой функции нам стоит генерировать новые ворота?
Можем ли мы сгенерировать всю игровую вселенную сразу?
Могут ли наши функции остаться чистыми, несмотря на случайную генерацию?

### Ленивый if

Чтобы найти элегантное решение для реализации нашей игры, мы рассмотрим несколько упрощённых ситуаций.
Но для начала давайте вспомним, как работает вычисление функций в Haskell.

Рассмотрим функцию f, принимающую значение типа Bool, два значения типа a и возвращающую значение типа a.
Если значение первого аргумента True — функция возвращает второй аргумент. Иначе — третий.
Например, f True 1 2 вернёт 1, а f False "привет" "мир" вернёт "мир".
Заметим, что сопоставление с образом происходит только для первого аргумента.
В Haskell это означает, что для вычисления функции f необходимо вычислить лишь первый аргумент.
Будут ли вычисляться остальные аргументы зависит от значения первого!
Например, если мы попытаемся вычислить f True 1 (2 `div` 0), то получим 1.
Деление на ноль не произойдёт, поскольку вычисление этого выражение не нужно для получения результата.

Порядок вычислений, при котором выражения вычисляются по необходимости называется ленивым.
По сравнению с энергичным порядков вычислений, при котором все аргументы вычисляются перед тем,
как применить функцию, ленивый порядок имеет ряд преимуществ.
Например, ленивый порядок вычислений позволяет определять управляющие конструкции, которые должны быть встроены
в языках с энергичным порядком вычислений. И в самом деле, наша функция `f` — не что иное как оператор `if`!
Несмотря на то, что в Haskell присутствует специальный синтаксис для if then else,
это не более чем синтаксический сахар для функции `ifThenElse`.

Многие языки с энергичным порядком вычислений всё же предлагаю ленивость в одном случае — для вычисления логических операций.
Действительно, во многих языках выражение `x && f(y)` не будет вычислять функцию `f`,
если `x` ложно. В Haskell нам не нужно дополнительное правило для логических операций,
ведь мы можем определить ленивый `&&` самостоятельно.

Заметим, что поскольку сопоставление с образцом происходит по первому аргументу, операция `&&` ленива по второму.
Это значит, что когда мы вычисляем функцию `&&` только второй аргумент может быть не вычислен.

### Ленивые структуры данных

В Наskell ленивы не только функции, но и структуры данных.
Например, мы можем построить кортеж, содержащий `1` и ``2 `div` 0``.
До тех пор, пока нам не понадобится второй элемент этого кортежа, он не будет вычислен.
Например, мы можем спокойно получить первый элемент, используя функцию `fst`.
Вместо деления на ноль мы могли бы использовать просто очень объемное вычисление.
Например, факториал миллиона. В этом случае получить второй элемент можно без ошибки,
но придётся довольно долго подождать.

Дело обстоит намного интереснее с рекурсивными структурами данных, такими как список.
В Haskell у списка есть 2 конструктора — конструктор пустого списка, который просто возвращает пустой список.
И конструктор непустого списка, который принимает на вход голову, хвост и составляет новый список.
Конструктор непустого списка ленив и не вычисляет свои аргументы до тех пор, пока они кому-то не понадобятся.

Например, функция `length` вычисляет длину списка, но для этого не использует значения в списке.
А значит, мы можем вычислить длину списка ``[1, 2 `div` 0, 3]``, не выполняя деление!

Теперь представьте, что мы хотим вычислить, все ли числа в списке чётные.
Для этого мы можем сначала проверить чётность каждого числа, используя функцию `map even`, а затем проверить,
что для всех чисел мы получили `True`. Реализуем функцию `and`, проверяющую что входной список состоит только из `True`.
Если список пуст — мы возвращаем `True`, а если список не пуст, мы используем операцию `&&` для головы и рекурсивного вызова от хвоста списка.
Поскольку `&&` ленив по второму аргументу, нам не придётся вычислять хвост списка, если голова списка — `False`.
Например, для списка чисел ``[0, 1, 2 `div` 0, 3]``, результат применения `map even` будет выглядеть так.
Функция `and` будет перебирать значения по очереди и как только дойдёт до `even 1` вычисление прекратится, поскольку 1 — нечётное число.
Таким образом, деления на ноль опять не произойдёт.

Определим вспомогательную функцию `take`. Эта функция будет брать из входного списка заданное кол-во элементов
или все элементы, если список короче нужной длины. От пустого списка мы возвращаем пустой список, а от непустого
берём элемент, если `n` больше нуля. Иначе — возвращаем пустой список.

Ленивые конструкторы списков позволяют не только не вычислять значения в списке, но и не вычислять целый хвост списка,
когда он не нужен. Это значит, что хвост может быть любой длины. Например, определим список `ones`, состоящий из единиц.
Голова этого списка — `1`, а хвост — сам список `ones`. Из-за ленивого порядка вычислений, `ones` не будет вызван рекурсивно
до тех пор, пока очередная единица не понадобится вызывающей стороне.
Например, мы запросто можем получить первые пять элементов списка `ones`, используя функцию `take`.

Конечно, намного полезнее иметь список с различными значениями.
Например, на практике часто используются диапазоны чисел. Скажем, целые числа от 1 до 10.
Мы можем реализовать функцию `fromTo`, принимающую на вход два числа и возвращающую диапазон чисел между ними.
Если `n` меньше `m` мы начинаем список с `n` и вычисляем хвост списка рекурсивно от `n + 1`. Иначе мы получаем пустой список.
Теперь мы можем получить список чисел от 1 до 10, вычислив `fromTo 1 10`.

Благодаря ленивости мы можем создать также открытый диапазон чисел.
Например, мы можем реализовать функцию `from`, принимающую число и возвращающую список чисел от `n` до бесконечности.
Реализация функции `from` похожа на реализацию `fromTo`, но теперь нам не нужно проверять условие `n < m`.

Мы можем реализовать `fromTo` через `from`, используя функцию `take`. Действительно, диапазон чисел от `n` до `m` —
это первые `n - m + 1` элементов списка `from n`.

Диапазоны часто нужны в программировании, и поэтому Haskell предоставляет удобный синтаксис для их создания.
Диапазон чисел от `n` до `m` можно записать в виде списка `n` две точки `m`.
Открытый диапазон чисел от `n` можно записать в виде списка `n` две точки.
Также существует синтаксис для арифметической прогрессии с шагом, отличным от 1.
Список `n`, `k`, две точки, `m` создаст диапазон чисел от `n` до `m` с шагом `k - n`.
Список `n`, `k`, две точки создаст арифметическую прогрессию чисел от `n` с шагом `k - n`.

### Возвращение к мотивирующему примеру

Реализация функции `fromTo` через `from` и `take` показывает, что ленивость позволяет разделить генерацию и обработку данных,
не теряя в эффективности и не вводя новых сущностей. Это именно то, что нам нужно для реализации нашей игры!

Действительно, вместо того, чтобы встраивать генерацию случайных чисел в чистую функцию обновления, было бы здорово построить
бесконечный список ворот при инициализации и использовать только те ворота, которые находятся на экране в данный момент.
И ленивый порядок вычислений позволяет нам это сделать!

В качестве представления для ворот выберем кортеж, содержащий относительное положение и высоту ворот.
Для первых ворот положение будет означать расстояние от персонажа до ворот, а для остальных — расстояние от предыдущих ворот.
Поскольку расстояние между воротами постоянное, мы можем инициализировать одни ворота, зная лишь их высоту.

Чтобы построить игровую вселенную, нам нужно получить бесконечный список высот ворот.
Чтобы высота была случайной, нам необходимо использовать модуль для работы со случайными значениями `System.Random`.
В частности нас интересует функция `randomRs`, которая может сгенерировать бесконечный список случайных значений в заданном интервале.
Функция принимает на вход границы интервала и генератор. На выходе мы получаем бесконечный список случайных значений.

Заметим, что функция `randomRs` чистая! Генератор, который мы передаём функции на вход на самом деле является генератором псевдослучайных чисел,
вычисление которых не требует побочных эффектов! Но мы знаем, что без побочных эффектов мы не можем получить настоящее случаное поведение!
И в самом деле, побочный эффект нам требуется. Но только при создании генератора!

Функция `newStdGen` из модуля `System.Random` создаёт новый генератор, используя побочные эффекты.
Мы не будем сейчас вдаваться в подробности работы этой функции и работы с побочными эффектами в Haskell.
Пока нам достаточно знать, что генератор может быть создан кем-то и передан в нашу чистую функцию инициализации ворот.

Таким образом, наша функция инициализации ворот принимает на вход генератор случайных значений и возвращает бесконечный список ворот.
Для этого она применяет функцию инициализации к каждой случайной высоте, полученной при помощи функции `randomRs`.

Теперь нам осталось реализовать функцию обновления ворот.
Если ворот нет — то список остаётся пустым (на случай если список ворот был конечным).
Если ворота находятся слишком близко, мы удаляем их из списка, делая рекурсивный вызов для оставшихся ворот и времени.
Иначе мы просто пододвигаем ближайшие ворота.

Отлично, теперь наш персонаж может перемещаться по бесконечной игровой вселенной и всё благодаря ленивым вычислениям!

Чтобы завершить игру нам нужно реализовать функцию, определяющую столкновение персонажа с воротами.
Функция столкновения с одними воротами уже есть, реализуйте функцию `collision`, определяющую столкновение персонажа с воротами на экране.
Функция принимает на вход потенциально бесконечный список ворот и состояние игрока.

Ссылка на проект с игрой «Flappy Lambda» находиться в описании под видео.
Успехов!
