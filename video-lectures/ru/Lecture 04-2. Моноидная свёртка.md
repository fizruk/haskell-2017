Моноидная свёртка
===

### Мотивирующий пример

Давайте реализуем игру, в которой персонаж бродит по случайно сгенерированному лабиринту!
Один из способов построить лабиринт — это рекурсивно разбивать пространство на всё меньшие области,                           оставляя случайные переходы между подобластями.
Такое рекурсивное разбиение пространства также позволяет нам быстро находить стены лабиринта в заданной окрестности.
Для прототипирования мы, конечно же можем использовать обычные списки.
Но если нам захочется строить большие лабиринты, нам захочется поменять структуру хранения, например, на двумерное дерево.
Можем ли мы спроектировать программу таким образом, чтобы изменение структуры затронуло лишь небольшую часть нашей программы?

### Расстановка скобок и деревья

Давайте взглянем ещё раз на расстановку скобок в выражении.
Каждой расстановке скобок соответствует своё дерево вычислений.
Например, при правой свёртке корень такого дерева соответствует самой левой операции, а поддеревья —
первому элементу и дереву для хвоста списка.
При левой свёртке корень дерева будет соответствовать самой правой операции.
Как видите, оба дерева получаются сильно перекошены в одну или другую сторону.
Мы можем расставить скобки по-другому и получить другие, более сбалансированные деревья.
Вспомним, что алгебраические типы данных в Haskell — это по сути деревья.
Альтернативы предлагают разные типы узлов, а поля конструктора содержат значения и поддеревья.
При свёртке значений дерева мы естественным образом получаем расстановку скобок, соответствующую структуре дерева.
Например, при обычном рекурсивном подсчёте суммы элементов в двоичном дереве мы получаем следующую расстановку.
Обычно при свёртке значений дерева (например, подсчёте суммы элементов), нас не интересует расстановка скобок.
Чтобы абстрагироваться от скобок мы можем использовать `Monoid`.
Таким образом, мы можем реализовать моноидную свёртку для нашего двоичного дерева.
Если дерево пустое, мы возвращаем нейтральный элемент моноида — `mempty`.
В узле дерева мы вычисляем моноидную сумму для левого поддерева, складываем со значением в узле и суммой для правого поддерева.
Теперь мы можем вычислить сумму дерева, используя моноидную свёртку и тип-обёртку `Sum`.
Для того, чтобы обернуть каждое значение в дереве, используем `fmap`.
Затем применим свёртку и развернём результат.

### Класс типов `Foldable`

Поскольку мы можем определить моноидную свёртку для многих структур, в Haskell существует класс типов, предоставляющий соответствующий интерфейс.
Класс типов `Foldable`, как и `Functor`, работает с конструкторами типов с одним параметром.
У этого класса существует множество методов, из которых основной — `foldMap`.
`foldMap` — это комбинация отображения и моноидной свёртки.
Реализуем экземпляр класса `Foldable` для списков. Тип `foldMap` для списков принимает следующий вид.
`foldMap f` — это композиция `map f` и `mconcat`.
Реализуем экземпляр класса `Foldable` для `Maybe`. Тип `foldMap` для `Maybe` принимает такой вид.
В случае `Nothing` мы возвращаем нейтральный элемент.
В случае `Just x` — просто применяем функцию к значению.
Поскольку `Maybe a` не может содержать больше одного элемента, операция `mappend` нам не пригодилась.
Экземпляр для `Tree` будет соответствовать моноидной свёртке, которую мы реализовали раньше.
Однако, теперь нам необходимо применить функцию к каждому значению в дереве, прежде чем складывать.
Давайте попробуем определить дерево с произвольным количеством поддеревьев.
Определим тип `RoseTree` с одним конструктором, содержащим значение в узле, и список поддеревьев.
Список может содержать несколько поддеревьев. Пустой список будет означать лист дерева.
Попробуем определить экземпляр класса типов `Foldable` для такого дерева.
Тип `foldMap` для `RoseTree` принимает следующий вид.
У нас есть только один конструктор.
К значению в узле применяем функцию и складываем результат для списка поддеревьев.
Чтобы вычислить сумму для списка поддеревьев, сначала вычислим сумму каждого поддерева.
Используем функцию `map` с рекурсивным вызовом моноидной свёртки дерева.
Теперь мы можем сложить результаты, полученные для каждого дерева, при помощи моноидной свёртки списка — функции `mconcat`.
Заметим, что комбинация `map` и `mconcat` — это `foldMap` для списка!
Мы можем также определить экземпляр для `Either e`.
Напомню, что `Either` принимает на вход два параметра, поэтому мы частично применяем его к одному аргументу.
Таким образом мы получаем конструктор типов с одним параметром, который мы можем использовать с классом `Foldable`.

Тип `foldMap` для `Either e` мы получаем, заменив `f` на `Either e`.
Если мы получили `Right x`, мы применяем функцию к значению.
Если мы получили `Left y` у нас нет значений нужного типа и мы вынуждены вернуть `mempty`.
Как и в случае с `Maybe`, операция `mappend` нам не пригодилась.

### Обобщённые функции

`foldMap` позволяет определить множество полезных функций сразу для множества структур!
Например, мы можем теперь реализовать функцию `and` в общем виде.
Функция будет принимать на вход структуру `t` со значениями типа `Bool`, и возвращать логическое И всех значений.
`t` — это переменная конструктора типа с одним типом-параметром.
Чтобы использовать моноидную свёртку, добавим ограничение `Foldable t`.
Моноид, который мы можем использовать для получения логического И — это тип-обёртка `All`.
Используем `foldMap`, чтобы обернуть каждое значение и свернуть структру.
Теперь нам остаётся только развернуть результат.
Аналогичным образом мы можем реализовать обобщённую функцию `sum`.
Эта функция принимает на вход структуру `t` со значениями типа `a` и возвращает значение типа `a`.
При этом структура `t` должна принадлежать классу `Foldable`,                   а тип `a` — классу `Num`.
Для реализации используем тип-обёртку `Sum`.
Мы можем получить список всех значений любой структуры, определив функцию `toList`.
Эта функция принимает любое значение типа `t a` и возвращает список значений типа `a`.
Чтобы получить список значений, мы можем использовать список в качестве моноида.
Каждое значение мы можем обернуть в список из одного элемента и свернуть полученный результат.

Если элементы структуры уже являются моноидными значениями, нам не нужно применять дополнительную функцию.
Метод `fold` класса `Foldable` осуществляет только свёртку.
В качестве упражнения, реализуйте функцию `find`, производящую поиск в любой структуре `t`, принадлежащей классу `Foldable`.
Вам понадобится определить тип-обертку для `Maybe a` и определить подходящий экземпляр класса `Monoid`.

### Законы `Foldable`

Среди методов `Foldable` присутствует функция `foldr`.
Оказывается, правая свёртка и `foldMap` могут   быть  определены  друг  через друга.
Мы можем определить `foldMap` через правую свёртку, применяя к каждому элементу заданную функцию
и используя операцию `mappend` в качестве шага свёртки.
В качестве начального значения будет выступать `mempty`.
Чтобы определить `foldr` через `foldMap`, заметим, что тип шага свёртки каррирован.
Шаг свёртки принимает значение типа `a`, а возвращает функцию из `b` в `b`.
Мы знаем, что такие функции образуют моноид, для которого определён тип-обёртка `Endo`.
Выходит, мы можем применить функцию шага свёртки к каждому элементу структуры, обернуть результат в `Endo`, и затем свернуть, используя композицию функций. В результате мы получим функцию из `b` в `b`, которая ожидает начальное значение, чтобы вернуть результат свёртки!
Для определения экземпляра класса `Foldable` необходимо реализовать любой из двух основных методов — `foldMap` или `foldr`. Реализация второго получится автоматически.
Поскольку при свёртке структура разрушается, для `Foldable` нет интересных законов.
В частности, от реализации ожидается соответствие `foldr` и `foldMap`.
Если структура также относится к классу `Functor`, `foldMap` должен действительно быть комбинацией `fold` и `fmap`.

### Автоматический вывод

Как и в случае с классом `Functor`, реализация `Foldable` может быть получена автоматически.
Для этого необходимо включить соответствующее расширение.
Добавьте строчку `LANGUAGE DeriveFoldable` в самом верху вашего исходного файла.
Готово! Теперь вы можете добавить `Foldable` к списку выводимых классов типов.

### Возвращение к мотивирующему примеру

Вернёмся к лабиринту.
Пусть разбиение пространства представлено типом `Space a`, содержащим элементы типа `a`.
Лабиринт будет представлен таким разбиением со стенами лабиринта в качестве элементов.
Поиск стен в заданной окрестности мы можем разбить на два этапа.
Первый этап — отсечь области пространства, которые не пересекаются с окрестностью.
Второй этап — собрать все стены.
Пусть функция `crop` отсекает "лишние" области пространства.
Эта функция опирается на структуру разбиения пространства и именно её мы будем переписывать, если нам понадобится изменить структуру.
Получив стены, которые нас интересуют, мы можем отобразить их.
Вместо того, чтобы собирать стены в список, а затем применять свёртку списка, мы можем сразу свернуть структуру разбиения пространства.
Действительно, изображения образуют моноид с операцией наложения!
Мы так же можем рассчитать для каждой стены в окрестности, пересекает ли её персонаж, перемещающийся по лабиринту.
Реализуйте функцию `canMove`, определяющую, может ли персонаж переместиться из одной точки в другую, используя функции `crop` и `foldMap`.
Проект с лабиринтом находится в описании под видео.
Успехов!
4
3
2
1
