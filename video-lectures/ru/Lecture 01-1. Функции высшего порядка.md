Функции высшего порядка
===

### Мотивирующий пример

Представьте, что вы моделируете столкновение двух галактик.
Каждая галактика в нашей модели — это просто скопление взаимодействующих частиц.
Рассматривая различные конфигурации модели, вас интересуют следующие характеристики:
- центр масс;
- кинетическая энергия и угловой момент.
Значение каждой характеристики необходимо вычислить как для целой системы, так и для каждой галактики.
На первый взгляд кажется, что для вычисления этих различных характеристик необходимо реализовать три совершенно разные функции. Но если присмотреться, у этих функций может оказаться много общего.

### Простой пример (3 мин)

Для начала рассмотрим более простой пример. Допустим, нам дали список чисел и попросили вычислить их сумму.
Конечно, мы без труда можем реализовать такую функцию. Она принимает на вход список чисел и возвращает число.
Сумма пустого списка — ноль,
а сумма непустого списка — это первое число плюс сумма хвоста списка.
Мы отлично справились с заданием и теперь нас просят посчитать сумму квадратов.
Мы создаём новую функцию. Сумма пустого списка также равна нулю,
а сумма непустого списка равна квадрату первого числа плюс сумма квадратов хвоста списка.
Отлично! Но теперь нас просят посчитать сумму кубов.
Мы, конечно, идём и пишем ещё одну функцию. Сумма пустого списка равна нулю,
а сумма непустого списка равна кубу первого числа плюс сумма кубов хвоста списка.
Пока нам не выдали очередное задание, мы замечаем, что в этих функциях много похожего.

Действительно, все функции имеют одинаковый тип, а реализация отличается лишь тем,
что мы делаем с каждым числом списка.
В первом случае мы ничего с ним не делали. Во втором случае мы возводили его в квадрат.  A в третьем — в куб.
Мы можем перенести степень в параметр, чтобы получить единую функцию, которая заменит три предыдущие.
Эта функция будет принимать на вход степень, список чисел и возвращать число -
сумму чисел, возведённых в заданную степень.

Однако, теперь нас просят посчитать среднее квадратичное отклонение для списка чисел.
Хм… Среднее квадратичное отклонение — это корень суммы квадратов отклонений поделённый на кол-во чисел в списке.
Значение под корнем очень похоже на то, что нам уже приходилось вычислять.
Но теперь нам требуется отнять от каждого числа среднее значение, прежде чем возводить в квадрат.
Мы можем написать отдельную функцию для суммы квадратов отклонений.
Для пустого списка сумма — ноль.
Для непустого — квадрат отклонения первого значения плюс сумма для хвоста списка.
Здесь мы снова видим, что реализация отличается от наших предыдущих функций только тем,
что мы делаем с каждым значением в списке.
Может быть стоит вынести “то, что мы делаем с каждым значением” в параметр?
Мы можем записать любое “действие” над числом в виде функции из числа в число.
Например, возведение в квадрат можно записать как сечение функции возведения в степень.
Для вычисления квадрата отклонения мы можем использовать лямбда-функцию.
Теперь мы можем переписать нашу функцию с "тем, что мы делаем с каждым значением" качестве аргумента.
Для пустого списка мы по-прежнему возвращаем ноль,
а для непустого списка мы применяем заданную функцию к первому значению списка и складываем с суммой хвоста списка.

### Функции высшего порядка

Таким образом функция sumWith принимает на вход 2 аргумента —
функцию преобразования f и список чисел –
а на выходе мы получаем снова число.
Функции, принимающие на вход другие функции, называются
функциями высшего порядка. Такие функции бывают очень полезны
и в нашем случае функция `sumWith` позволила нам заменить четыре
другие функции.
Действительно, мы можем рассчитать сумму чисел при помощи sumWith,
передавая тождественную функцию в качестве аргумента.
Тождественная функция id ничего не делает со своим аргументом,
возвращая его в том же виде и позволяя нам получить просто сумму чисел.
Рассчитать сумму квадратов можно, передавая функцию возведения в квадрат.
Рассчитать среднее квадратичное отклонение можно,
используя лямбда-функцию, вычисляющую квадрат отклонения.
Интересно, что используя функцию sumWith, мы можем вычислить длину списка.
То есть можно подобрать такую функцию g, что sumWith g
будет вычислять кол-во чисел в списке.
Попробуйте самостоятельно найти такую функцию.

### Разделение труда

Функция sumWith оказалась очень полезной, но она делает два дела одновременно.
Во-первых она применяет заданную функцию к каждому числу в списке, чтобы получить слагаемые.
А во вторых, она вычисляет сумму этих слагаемых.
Оказывается, мы можем представить функцию sumWith в виде комбинации двух функций, каждая из которых будет делать лишь одно дело.
Одна функция будет просто считать сумму чисел — это функция sum, которую мы реализовали ещё в самом начале.
А другая функция будет применять заданную функцию к каждому числу в списке... и возвращать новый список,
который мы и передадим на вход функции sum.

Итого, функция sumWith оказывается комбинацией двух простых функций — sum и map.
В действительности, sumWith f является *композицией* функций sum и map f.
Реализация функции map не сильно отличается от функции sumWith.
Пустой список остаётся пустым, независимо от функции преобразования.
Для непустого списка мы применяем функцию к первому числу,
рекурсивно применяем map к хвосту и
полученные выражения являются новыми головой и хвостом списка.

### Параметрический полиморфизм

Давайте на секунду забудем сигнатуру типа функции map.
Мы можем построить тип функции, опираясь на реализацию.
Мы видим, что у неё как минимум два параметра — функция f и список.
Мы так же видим, что результат функции тоже список.
Мы пока не знаем тип элементов ни для входного, ни для выходного списка.
Обозначим тип элементов входного списка переменной типа a,
а тип элементов выходного списка — b.
Заметим, что функция f имеет один аргумент.
Также заметим, что функция f применяется к элементам входного списка,
а результат её применения составляет элементы выходного списка.
Выходит, тип аргумента f — это a, a тип результата — b.
Итого, функция map принимает на вход любую функцию из a в b,
список элементов типа a, и возвращает список элементов типа b.

Поскольку a и b — переменные типа, в месте применения функции map
мы можем подставить любые типы.
Например, чтобы посчитать сумму квадратов
мы можем использовать комбинацию функций sum и map.
Поскольку функция sum принимает на вход список чисел,
а функция возведения в квадрат переводит число в число,
в этом месте в типе функции map обе переменные заменяются на Double.
Но мы можем использовать map и с другими типами.
Например, если нам дан список слов, мы можем посчитать длину каждого слова
при помощи функции length.
В этом случае переменная типа a заменится на String,
а переменная типа b — на Int.
Способность функции быть использованной с разными типами называется *полиморфизмом*.
Вид полиморфизма, в котором используются переменные типа, называется
*параметрическим полиморфизмом*, потому что значения этих переменных также являются
параметрами функции. Но в отличие от аргументов функции, эти параметры определяются
автоматически в месте применения функции.

### Возвращение к мотивирующему примеру

Функция map является одной из наиболее часто используемых функций.
И неудивительно — мы видели, что она является основой для многих функций,
которые делают что-то с каждым элементом списка.
Вернёмся к моделированию столкновения галактик.
Точки и вектора представлены в нашей модели кортежами из двух координат.
Каждая частица представлена значением типа Particle и содержит данные о
своей массе, положении и векторе скорости.
Чтобы рассчитать центр масс системы нам необходимо реализовать функцию,
принимающую на вход список частиц, и возвращающую положение центра масс.
Центр масс — это взвешенная сумма положений частиц.
Вес положения каждой частицы — это отношение его массы к общей массе системы.
Чтобы вычислить массу системы, нам необходимо вычислить сумму масс всех частиц.
Другими словами, мы должны получить массу каждой частицы и затем сложить их.
Теперь, чтобы рассчитать центр масс, мы считаем сумму взвешенных положений.
Другими словами, для каждой частицы мы считаем её взвешенное положение, а затем
складываем получившиеся вектора.
Как видим, функция map пригодилась нам дважды при расчёте центра масс!

Перейдём к кинетической энергии системы.
Тут всё проще: кинетическая энергия системы —
это сумма кинетических энергий частиц, составляющих систему.
А кинетическая энергия частицы — это масса на квадрат модуля скорости пополам.
Значит, чтобы рассчитать кинетическую энергию системы,
мы должны рассчитать кинетическую энергию каждой частицы,
а затем сложить всё.
Угловой момент системы —
это сумма угловых моментов каждой частицы
относительно центра масс системы.
Я уверен, вы без труда сможете реализовать подсчёт углового момента.
Небольшая подсказка:
поскольку мы оперируем в двух измерениях,
вместо векторного произведения достаточно использовать косое,
потому что вектор углового момента будет
всегда направлен перпендикулярно плоскости моделирования.
Ссылка на проект с моделированием галактик
находится в описании под видео.

