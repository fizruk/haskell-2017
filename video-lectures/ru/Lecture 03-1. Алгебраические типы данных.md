Алгебраические типы данных
===

### Мотивирующий пример

Дерево квадрантов — это структура, которая часто используется для оптимизации вычислений в двух измерениях. Идея проста: в двумерном пространстве находятся объекты, для которых проходят вычисления.
Сначала двумерное пространство делится на четыре квадранта.
Затем каждый квадрант делится ещё на четыре квадранта и так далее.
До тех пор, пока в каждом квадранте не останется один или ноль объектов.
Если много объектов сосредоточено в одном месте — в этом месте квадрантов будет больше, а сами они будут мельче.
Если в большой части пространства объектов нет — там будет мало квадрантов, но они будут крупнее.
Такое деление пространства позволяет быстро находить объекты, находящиеся рядом и соответственно производить вычисления быстрее.
Дерево квадрантов используется для обработки и сжатия изображений, хранения разряженных данных, эффективного расчёта столкновений на плоскости, моделирования клеточных автоматов и так далее.
Что ж, выглядит увлекательно, но как нам реализовать такую структуру на Haskell?

### Перечисления

Мы уже знакомы со многими типами, например, `Bool`, `Int`, `Maybe a`.
Но стандартных типов не хватит на все случаи жизни, и нам хочется определять свои собственные типы данных.
Мы можем делать это при помощи ключевого слова `data`.
Например, взглянем на определение типа `Bool` в стандартной библиотеке.
Ключевое слово `data` означает "определить новый тип". Далее всё до знака "равно" — это *тип*, который мы определяем.
После знака равно следуют *конструкторы значений*. Они определяют, какие значения составляют наш тип.
Вертикальная черта читается как ИЛИ.
Таким образом, тип `Bool` может иметь значение `False` или `True`.
Имена типов, а также имена конструкторов значений обязаны начинаться с заглавной буквы!
Мы можем использовать простое перечисление значений, чтобы определить, например, расу персонажа в ролевой игре.
Или, чтобы определить игрока в шахматах.

### Суммы произведений

Теперь подумайте, как бы мы могли представить геометрические фигуры.
Например, круг мы можем представить в виде кортежа, содержащего координаты центра и радуис.
Однако, глядя на такой тип не совсем понятно, что из этого координаты, а что — радиус.
Да и непонятно, что это должен быть круг, а не, скажем, вектор в трёхмерном пространстве.
Вместо безымянного кортежа, давайте создадим новый тип `Shape`, определяющий геометрические фигуры.
Для круга мы можем определить конструктор значений `Circle` с двумя полями, задающими его центр и радиус.
Для прямоугольника мы можем определить конструктор значений `Rectangle`, с двумя полями — координатами левой нижней и правой верхней вершин.
Поля конструкторов значений на самом деле являются их параметрами. Действительно, проверим типы конструкторов.
Выходит, конструкторы значений — это функции, принимающие значения полей и возвращающие значения типа `Shape`.
Теперь реализуем функцию, определяющую площадь геометрических фигур. Эта функция будет принимать на вход значение типа `Shape`.
Мы не можем написать функцию, принимающую на вход значение типа `Circle`, поскольку `Circle` — это не тип, это один из конструкторов значений типа `Shape`.
Но что мы можем делать с конструкторами значений, так это использовать их при сопоставлении с образцом.
Для конструктора `Circle` мы используем формулу `pi * r^2`.
А для конструктора `Rectangle` вычисляем произведение длин сторон.
Мы можем проверить нашу функцию в интерпретаторе.
Кстати, если мы попробуем просто вывести значение круга, мы получим ошибку. Это потому, что Haskell не знает, как отображать наш круг.
Для отображения интерпретатор использует функцию `show` из класса типов `Show`. Мы можем добавить реализацию экземпляра этого класса для нашей структуры автоматически, дописав `deriving (Show)` в конце определения нашей структуры.
Теперь интерпретатор может запросто вывести на экран значения типа `Shape`.

### Синтаксис записей

Иногда всё же полям полезно давать имена. Например, взгляните на такое определение типа `Person`.
Какое поле здесь отвечает за имя, фамилию, возраст, рост, номер телефона?
Мы могли бы написать функцию для каждого поля, достающую значение этого поля из структуры `Person`.
Это немного однообразно, но работает — теперь мы можем легко выделить нужную нам информацию.
Выписывать каждый раз функции для доступа к полям скучно, поэтому в Haskell существует так называемый синтаксис записей. В этом синтаксисе мы группируем все поля в фигурные скобки и разделяем поля запятыми.
Каждое поле теперь имеет имя и тип.
Тип, который мы получили — ровно тот же, что и раньше. Записи в Haskell — это лишь синтаксический сахар, позволяющий автоматически получить функции доступа к каждому полю.
Например, полю `phone` соответствует функция доступа `phone`, принимающая на вход структуру `Person` и возвращающая номер телефона.

### Параметрические типы

Итак, конструкторы значений могут принимать на вход параметры-поля, чтобы построить значение заданного типа. Аналогичным образом, конструкторы типов могут принимать на вход параметры-типы, чтобы построить тип.
Давайте взглянем на уже знакомый нам тип `Maybe`. Вспомним, что всё, что находится между ключевым словом `data` и знаком "равно" — это тип.
В данном случае тип — это `Maybe a`.
`a` — это параметр, переменная типа, которая может быть использована при описании конструкторов значений.
`Maybe` называется *конструктором* типов, поскольку, чтобы получить тип, нам необходимо передать ему тип-параметр.
Например, мы можем построить типы `Maybe Int`, `Maybe Bool` или даже `Maybe (Maybe String)`.
Заметим, что поскольку `Maybe` без параметра — это не тип, а конструктор типа, мы не можем определить значения типа `Maybe`.
Ещё один знакомый нам тип с параметром — это список. Параметр типа списка — это тип его элементов. Например, мы можем построить тип список чисел или список списков строк.
Но, как и в случае с `Maybe`, мы не можем построить значения типа просто список, нам необходимо указать тип элементов.
Используя тип-параметр мы можем определить тип `V3` для представления векторов в трёхмерном пространстве.
Параметр будет определять тип компонент вектора.
Используя лишь один конструктор типов `V3` мы можем получить типы векторов с целыми координатами, вещественными или комплексными.
Чтобы реализовать функцию сложения векторов, нам необходимо использовать сложение компонент вектора.
Для этого нам необходимо наложить ограничение `Num` на тип компонент, поскольку операция `+` накладывает это ограничение на типы своих аргументов.
Ранее мы с вами пользовались ключевым словом `type`, чтобы определять синонимы типов.
В случае с `type` в отличие от `data` после знака "равно" следует тип, для которого определяется синоним.
Там не может быть альтернатив или конструкторов значений.
Например, тип `String` определён как синоним списка элементов типа `Char`.
Cлева от знака "равно" при описании синонима мы можем использовать типы-параметры так же, как и при определении собственных типов.
Например, мы можем определить тип ассоциативных списков, использующий два типа-параметра — один для ключей, второй — для значений.
Функция, находящая значение по ключу в ассоциативном списке принимает на вход ключ типа `k`, ассоциативный список с ключами типа `k` и значениями типа `v` и возвращает значение типа `Maybe v`.
Для сравнения ключей этой функции понадобится ограничение `Eq k`.
Ещё один полезный тип с двумя параметрами — это тип `Either a b`.
Этот тип имеет два конструктора значений — `Left` и `Right`.
`Left` содержит только значение типа `a`, а `Right` — значение типа `b`.
Мы использовали ранее тип `Maybe a` для того, чтобы сигнализировать о специальных ситуациях.
Например, функция `find` возвращает `Nothing`, если в списке нет элементов, удовлетворяющих предикату.
Тип `Either a b` может быть использован аналогичным образом, при этом конструктор `Right` будет соответствовать конструктору `Just`,
а `Left` — конструктору `Nothing`. При этом в отличие от `Nothing` у `Left` есть параметр, который мы можем использовать, чтобы указать причину, по которой ответ не может быть получен.
Например, функция `readEither` из модуля `Text.Read` возвращает значение типа `Either String a`.
При этом конструктор `Left` используется для сообщения об ошибке, если такая произошла при чтении.

### Рекурсивные типы

Итак, типы могут иметь несколько конструкторов значений, каждый из которых может иметь несколько полей.
Каждое поле при этом может иметь любой тип. В том числе тот тип, который мы определяем!
Например, мы можем определить свой собственный тип списков.
У нашего типа будет один параметр, определяющий тип элементов списка.
Наш список может быть пустым или состоять из головы и хвоста списка.
Голова списка — это элемент типа `a`, а хвост — такой же список элементов типа `a`. Наше определение работает точь-в-точь как обычные списки в Haskell.
Например, мы можем определить список чисел от одного до пяти, используя наш тип списков.
Мы можем определить также двоичное дерево поиска, используя тип рекурсивно дважды. Тип `Tree a` будет иметь два конструктора значений — конструктор листьев дерева и конструктор узлов.
Листья дерева не содержат никакой информации, а каждый узел содержит значение типа `a` и два поддерева.
В двоичном дереве поиска значения в левом поддереве всегда меньше значения в узле, а значения в правом — больше.
Мы можем реализовать функцию поиска в дереве, используя это свойство.
Функция будет принимать на вход значение типа `a`, дерево типа `Tree a` и возвращать значение типа `Bool`.
Чтобы сравнивать значения типа `a` мы используем ограничение `Ord a`.
Если дерево пустое — нашего значения нет и мы вынуждены вернуть `False`.
Если же мы находимся в узле дерева, то мы должны проверить значение в узле.
Если значение совпадает с тем, что мы ищем — мы возвращаем `True`.
Если значение в узле меньше, чем нужно — мы ищем в правом поддереве. Иначе — в левом.
В качестве упражнения реализуйте функции `insert` и `delete`, выполняющие вставку и удаление элемента из двоичного дерева поиска.

### Алгебраические типы данных


Итак, типы в Haskell могут быть составлены при помощи алтернатив, каждая из которых представлена конструктором значений с несколькими полями.
Построение типов таким образом делает их алгебраическими.
А именно, использование альтернативы по сути является сложением типов, а объединение типов в кортежи или поля конструктора значений — умножением.
Эти простые операции дают начало целой алгебре типов — очень интересной теме, в детали которой мы пока не будем вдаваться.

### Возвращение к мотивирующему примеру

Теперь мы готовы и можем вернуться к дереву квадрантов.
Наше пространство, которое мы будем разбивать, будет единичным квадратом с нижним левым углом в начале координат.
Каждый объект будет просто точкой в этом квадрате.
На самом деле нам не так важно, каков тип объектов.
Это могут быть просто точки, физические объекты или что-то ещё.
Поэтому будем определять тип `QuadTree a`, представляющий дерево квадрантов с объектами любого типа `a`.
Прежде чем определять само дерево, определим необходимые вспомогательные типы.
Для точек определим синоним `Point` — пару координат.
Для представления границ пространства, охватываемого деревом, определим синоним `Rect` — левую нижнюю и правую верхнюю вершины.
Поскольку в дереве квадрантов каждый узел будет иметь ровно четыре поддерева, определим вспомогательный тип `Quad a`, содержащий четыре значения типа `a`. Например, `Quad Int` будет содержать четыре значения типа `Int`.
Каждый квадрант может быть либо пустым, либо содержать один объект, либо состоять из четырёх поддеревьев.
Определим тип `Quadrant a`. Для трёх возможных вариантов создадим три конструктора значений.
Для пустого квадранта будем использовать конструктор `Empty`.
Для конструктора, содержащего один объект — конструктор `Bucket`, который содержит объект и его положение.
А для разбиения — конструктор `Split`. Этот конструктор должен принимать четыре поддерева на вход.
Используем тип `Quad (QuadTree a)` чтобы указать, что здесь должно быть четыре поддерева.
Теперь осталось определить тип самого дерева.
Дерево — это просто квадрант с заданными границами пространства.
Нам нужен лишь один конструктор `QuadTree a` с двумя полями.
Первое поле — границы пространства типа `Rect`.
Второе — квадрант, занимающий это пространство типа `Quadrant a`
Определим функцию вставки объекта в заданной точке в существующем дереве квадрантов.
Функция принимает на вход координаты точки, сам объект, дерево квадрантов и возвращает новое дерево квадрантов.
Для реализации нам нужно рассмотреть три варианта квадранта в корне дерева.
Если квадрант пустой — мы просто добавляем туда объект, используя конструктор `Bucket`.
Если в квадранте уже есть объект, нам нужно создать новое разбиение и добавить каждый из двух объектов в полученное дерево.
Если квадрант разбит, мы выбираем подходящий подквадрант и вставляем объект туда рекурсивно.
Реализуйте функцию `getRange`, выбирающую объекты из дерева квадрантов, в заданной прямоугольной области.
Функция принимает на вход границы области, дерево квадрантов и возвращает список объектов типа `a`.
Ссылка на проект с визуализацией дерева квадрантов находится в описании под видео.
Успехов!
